"""
This type stub file was generated by pyright.
"""

from datetime import datetime
from python_utils import types
from collections import abc
from . import base

"""
This type stub file was generated by pyright.
"""
logger = ...
T = types.TypeVar('T')
class ProgressBarMixinBase:
    def __init__(self, **kwargs) -> None:
        ...
    
    def start(self, **kwargs):
        ...
    
    def update(self, value=...):
        ...
    
    def finish(self):
        ...
    
    def __del__(self):
        ...
    


class ProgressBarBase(abc.Iterable, ProgressBarMixinBase):
    ...


class DefaultFdMixin(ProgressBarMixinBase):
    def __init__(self, fd: types.IO = ..., is_terminal: bool | None = ..., line_breaks: bool | None = ..., enable_colors: bool | None = ..., **kwargs) -> None:
        ...
    
    def update(self, *args, **kwargs):
        ...
    
    def finish(self, *args, **kwargs):
        ...
    


class ResizableMixin(ProgressBarMixinBase):
    def __init__(self, term_width: int | None = ..., **kwargs) -> None:
        ...
    
    def finish(self):
        ...
    


class StdRedirectMixin(DefaultFdMixin):
    def __init__(self, redirect_stderr: bool = ..., redirect_stdout: bool = ..., **kwargs) -> None:
        ...
    
    def start(self, *args, **kwargs):
        ...
    
    def update(self, value: float = ...):
        ...
    
    def finish(self, end=...):
        ...
    


class ProgressBar(StdRedirectMixin, ResizableMixin, ProgressBarBase):
    '''The ProgressBar class which updates and prints the bar.

    Args:
        min_value (int): The minimum/start value for the progress bar
        max_value (int): The maximum/end value for the progress bar.
                            Defaults to `_DEFAULT_MAXVAL`
        widgets (list): The widgets to render, defaults to the result of
                        `default_widget()`
        left_justify (bool): Justify to the left if `True` or the right if
                                `False`
        initial_value (int): The value to start with
        poll_interval (float): The update interval in seconds.
            Note that if your widgets include timers or animations, the actual
            interval may be smaller (faster updates).  Also note that updates
            never happens faster than `min_poll_interval` which can be used for
            reduced output in logs
        min_poll_interval (float): The minimum update interval in seconds.
            The bar will _not_ be updated faster than this, despite changes in
            the progress, unless `force=True`.  This is limited to be at least
            `_MINIMUM_UPDATE_INTERVAL`.  If available, it is also bound by the
            environment variable PROGRESSBAR_MINIMUM_UPDATE_INTERVAL
        widget_kwargs (dict): The default keyword arguments for widgets
        custom_len (function): Method to override how the line width is
            calculated. When using non-latin characters the width
            calculation might be off by default
        max_error (bool): When True the progressbar will raise an error if it
            goes beyond it's set max_value. Otherwise the max_value is simply
            raised when needed
            prefix (str): Prefix the progressbar with the given string
            suffix (str): Prefix the progressbar with the given string
        variables (dict): User-defined variables variables that can be used
            from a label using `format='{variables.my_var}'`.  These values can
            be updated using `bar.update(my_var='newValue')` This can also be
            used to set initial values for variables' widgets

    A common way of using it is like:

    >>> progress = ProgressBar().start()
    >>> for i in range(100):
    ...     progress.update(i + 1)
    ...     # do something
    ...
    >>> progress.finish()

    You can also use a ProgressBar as an iterator:

    >>> progress = ProgressBar()
    >>> some_iterable = range(100)
    >>> for i in progress(some_iterable):
    ...     # do something
    ...     pass
    ...

    Since the progress bar is incredibly customizable you can specify
    different widgets of any type in any order. You can even write your own
    widgets! However, since there are already a good number of widgets you
    should probably play around with them before moving on to create your own
    widgets.

    The term_width parameter represents the current terminal width. If the
    parameter is set to an integer then the progress bar will use that,
    otherwise it will attempt to determine the terminal width falling back to
    80 columns if the width cannot be determined.

    When implementing a widget's update method you are passed a reference to
    the current progress bar. As a result, you have access to the
    ProgressBar's methods and attributes. Although there is nothing preventing
    you from changing the ProgressBar you should treat it as read only.
    '''
    value: T
    max_value: T
    end_time: datetime
    start_time: datetime
    seconds_elapsed: float
    _DEFAULT_MAXVAL = base.UnknownLength
    _MINIMUM_UPDATE_INTERVAL = ...
    def __init__(self, min_value=..., max_value=..., widgets=..., left_justify=..., initial_value=..., poll_interval=..., widget_kwargs=..., custom_len=..., max_error=..., prefix=..., suffix=..., variables=..., min_poll_interval=..., **kwargs) -> None:
        '''
        Initializes a progress bar with sane defaults
        '''
        ...
    
    @property
    def dynamic_messages(self):
        ...
    
    @dynamic_messages.setter
    def dynamic_messages(self, value):
        ...
    
    def init(self):
        '''
        (re)initialize values to original state so the progressbar can be
        used (again)
        '''
        ...
    
    @property
    def percentage(self):
        '''Return current percentage, returns None if no max_value is given

        >>> progress = ProgressBar()
        >>> progress.max_value = 10
        >>> progress.min_value = 0
        >>> progress.value = 0
        >>> progress.percentage
        0.0
        >>>
        >>> progress.value = 1
        >>> progress.percentage
        10.0
        >>> progress.value = 10
        >>> progress.percentage
        100.0
        >>> progress.min_value = -10
        >>> progress.percentage
        100.0
        >>> progress.value = 0
        >>> progress.percentage
        50.0
        >>> progress.value = 5
        >>> progress.percentage
        75.0
        >>> progress.value = -5
        >>> progress.percentage
        25.0
        >>> progress.max_value = None
        >>> progress.percentage
        '''
        ...
    
    def get_last_update_time(self):
        ...
    
    def set_last_update_time(self, value):
        ...
    
    last_update_time = ...
    def data(self):
        '''

        Returns:
            dict:
                - `max_value`: The maximum value (can be None with
                  iterators)
                - `start_time`: Start time of the widget
                - `last_update_time`: Last update time of the widget
                - `end_time`: End time of the widget
                - `value`: The current value
                - `previous_value`: The previous value
                - `updates`: The total update count
                - `total_seconds_elapsed`: The seconds since the bar started
                - `seconds_elapsed`: The seconds since the bar started modulo
                  60
                - `minutes_elapsed`: The minutes since the bar started modulo
                  60
                - `hours_elapsed`: The hours since the bar started modulo 24
                - `days_elapsed`: The hours since the bar started
                - `time_elapsed`: The raw elapsed `datetime.timedelta` object
                - `percentage`: Percentage as a float or `None` if no max_value
                  is available
                - `dynamic_messages`: Deprecated, use `variables` instead.
                - `variables`: Dictionary of user-defined variables for the
                  :py:class:`~progressbar.widgets.Variable`'s

        '''
        ...
    
    def default_widgets(self):
        ...
    
    def __call__(self, iterable, max_value=...):
        'Use a ProgressBar to iterate through an iterable'
        ...
    
    def __iter__(self):
        ...
    
    def __next__(self):
        ...
    
    def __exit__(self, exc_type, exc_value, traceback):
        ...
    
    def __enter__(self):
        ...
    
    next = ...
    def __iadd__(self, value):
        'Updates the ProgressBar by adding a new value.'
        ...
    
    def increment(self, value=..., *args, **kwargs):
        ...
    
    def update(self, value=..., force=..., **kwargs):
        'Updates the ProgressBar to a new value.'
        ...
    
    def start(self, max_value=..., init=...):
        '''Starts measuring time, and prints the bar at 0%.

        It returns self so you can use it like this:

        Args:
            max_value (int): The maximum value of the progressbar
            reinit (bool): Initialize the progressbar, this is useful if you
                wish to reuse the same progressbar but can be disabled if
                data needs to be passed along to the next run

        >>> pbar = ProgressBar().start()
        >>> for i in range(100):
        ...    # do something
        ...    pbar.update(i+1)
        ...
        >>> pbar.finish()
        '''
        ...
    
    def finish(self, end=..., dirty=...):
        '''
        Puts the ProgressBar bar in the finished state.

        Also flushes and disables output buffering if this was the last
        progressbar running.

        Args:
            end (str): The string to end the progressbar with, defaults to a
                newline
            dirty (bool): When True the progressbar kept the current state and
                won't be set to 100 percent
        '''
        ...
    
    @property
    def currval(self):
        '''
        Legacy method to make progressbar-2 compatible with the original
        progressbar package
        '''
        ...
    


class DataTransferBar(ProgressBar):
    '''A progress bar with sensible defaults for downloads etc.

    This assumes that the values its given are numbers of bytes.
    '''
    def default_widgets(self):
        ...
    


class NullBar(ProgressBar):
    '''
    Progress bar that does absolutely nothing. Useful for single verbosity
    flags
    '''
    def start(self, *args, **kwargs):
        ...
    
    def update(self, *args, **kwargs):
        ...
    
    def finish(self, *args, **kwargs):
        ...
    


