"""
This type stub file was generated by pyright.
"""

from asyncio import Future
from typing import Any, Callable, Coroutine, Generator, Iterable, Union
from twisted.internet.defer import Deferred, DeferredList
from twisted.python.failure import Failure

"""
Helper functions for dealing with Twisted deferreds
"""
def defer_fail(_failure: Failure) -> Deferred:
    """Same as twisted.internet.defer.fail but delay calling errback until
    next reactor loop

    It delays by 100ms so reactor has a chance to go through readers and writers
    before attending pending delayed calls, so do not set delay to zero.
    """
    ...

def defer_succeed(result) -> Deferred:
    """Same as twisted.internet.defer.succeed but delay calling callback until
    next reactor loop

    It delays by 100ms so reactor has a chance to go through readers and writers
    before attending pending delayed calls, so do not set delay to zero.
    """
    ...

def defer_result(result) -> Deferred:
    ...

def mustbe_deferred(f: Callable, *args, **kw) -> Deferred:
    """Same as twisted.internet.defer.maybeDeferred, but delay calling
    callback/errback to next reactor loop
    """
    ...

def parallel(iterable: Iterable, count: int, callable: Callable, *args, **named) -> DeferredList:
    """Execute a callable over the objects in the given iterable, in parallel,
    using no more than ``count`` concurrent calls.

    Taken from: https://jcalderone.livejournal.com/24285.html
    """
    ...

def process_chain(callbacks: Iterable[Callable], input, *a, **kw) -> Deferred:
    """Return a Deferred built by chaining the given callbacks"""
    ...

def process_chain_both(callbacks: Iterable[Callable], errbacks: Iterable[Callable], input, *a, **kw) -> Deferred:
    """Return a Deferred built by chaining the given callbacks and errbacks"""
    ...

def process_parallel(callbacks: Iterable[Callable], input, *a, **kw) -> Deferred:
    """Return a Deferred with the output of all successful calls to the given
    callbacks
    """
    ...

def iter_errback(iterable: Iterable, errback: Callable, *a, **kw) -> Generator:
    """Wraps an iterable calling an errback if an error is caught while
    iterating it.
    """
    ...

def deferred_from_coro(o) -> Any:
    """Converts a coroutine into a Deferred, or returns the object as is if it isn't a coroutine"""
    ...

def deferred_f_from_coro_f(coro_f: Callable[..., Coroutine]) -> Callable:
    """ Converts a coroutine function into a function that returns a Deferred.

    The coroutine function will be called at the time when the wrapper is called. Wrapper args will be passed to it.
    This is useful for callback chains, as callback functions are called with the previous callback result.
    """
    ...

def maybeDeferred_coro(f: Callable, *args, **kw) -> Deferred:
    """ Copy of defer.maybeDeferred that also converts coroutines to Deferreds. """
    ...

def deferred_to_future(d: Deferred) -> Future:
    """
    .. versionadded:: 2.6.0

    Return an :class:`asyncio.Future` object that wraps *d*.

    When :ref:`using the asyncio reactor <install-asyncio>`, you cannot await
    on :class:`~twisted.internet.defer.Deferred` objects from :ref:`Scrapy
    callables defined as coroutines <coroutine-support>`, you can only await on
    ``Future`` objects. Wrapping ``Deferred`` objects into ``Future`` objects
    allows you to wait on them::

        class MySpider(Spider):
            ...
            async def parse(self, response):
                d = treq.get('https://example.com/additional')
                additional_response = await deferred_to_future(d)
    """
    ...

def maybe_deferred_to_future(d: Deferred) -> Union[Deferred, Future]:
    """
    .. versionadded:: 2.6.0

    Return *d* as an object that can be awaited from a :ref:`Scrapy callable
    defined as a coroutine <coroutine-support>`.

    What you can await in Scrapy callables defined as coroutines depends on the
    value of :setting:`TWISTED_REACTOR`:

    -   When not using the asyncio reactor, you can only await on
        :class:`~twisted.internet.defer.Deferred` objects.

    -   When :ref:`using the asyncio reactor <install-asyncio>`, you can only
        await on :class:`asyncio.Future` objects.

    If you want to write code that uses ``Deferred`` objects but works with any
    reactor, use this function on all ``Deferred`` objects::

        class MySpider(Spider):
            ...
            async def parse(self, response):
                d = treq.get('https://example.com/additional')
                extra_response = await maybe_deferred_to_future(d)
    """
    ...

