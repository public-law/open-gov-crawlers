"""
This type stub file was generated by pyright.
"""

import copy
import collections
import six
from typing import Any, Optional

"""
This module contains data types used by Scrapy which are not included in the
Python Standard Library.

This module must not depend on any module outside the Standard Library.
"""
if six.PY2:
    Mapping = collections.Mapping
else:
    Mapping = collections.abc.Mapping
class MultiValueDictKeyError(KeyError):
    def __init__(self, *args, **kwargs):
        ...
    


class MultiValueDict(dict):
    """
    A subclass of dictionary customized to handle multiple values for the same key.

    >>> d = MultiValueDict({'name': ['Adrian', 'Simon'], 'position': ['Developer']})
    >>> d['name']
    'Simon'
    >>> d.getlist('name')
    ['Adrian', 'Simon']
    >>> d.get('lastname', 'nonexistent')
    'nonexistent'
    >>> d.setlist('lastname', ['Holovaty', 'Willison'])

    This class exists to solve the irritating problem raised by cgi.parse_qs,
    which returns a list for every key, even though most Web forms submit
    single name-value pairs.
    """
    def __init__(self, key_to_list_mapping=...):
        ...
    
    def __repr__(self):
        ...
    
    def __getitem__(self, key):
        """
        Returns the last data value for this key, or [] if it's an empty list;
        raises KeyError if not found.
        """
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def __copy__(self):
        ...
    
    def __deepcopy__(self, memo: Optional[Any] = ...):
        ...
    
    def get(self, key, default: Optional[Any] = ...):
        "Returns the default value if the requested data doesn't exist"
        ...
    
    def getlist(self, key):
        "Returns an empty list if the requested data doesn't exist"
        ...
    
    def setlist(self, key, list_):
        ...
    
    def setdefault(self, key, default: Optional[Any] = ...):
        ...
    
    def setlistdefault(self, key, default_list=...):
        ...
    
    def appendlist(self, key, value):
        "Appends an item to the internal list associated with key"
        ...
    
    def items(self):
        """
        Returns a list of (key, value) pairs, where value is the last item in
        the list associated with the key.
        """
        ...
    
    def lists(self):
        "Returns a list of (key, list) pairs."
        ...
    
    def values(self):
        "Returns a list of the last value on every key list."
        ...
    
    def copy(self):
        "Returns a copy of this object."
        ...
    
    def update(self, *args, **kwargs):
        "update() extends rather than replaces existing key lists. Also accepts keyword args."
        ...
    


class SiteNode(object):
    """Class to represent a site node (page, image or any other file)"""
    def __init__(self, url):
        self.url = ...
        self.itemnames = ...
        self.children = ...
        self.parent = ...
    
    def add_child(self, node):
        ...
    
    def to_string(self, level=...):
        ...
    


class CaselessDict(dict):
    __slots__ = ...
    def __init__(self, seq: Optional[Any] = ...):
        ...
    
    def __getitem__(self, key):
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def __delitem__(self, key):
        ...
    
    def __contains__(self, key):
        ...
    
    has_key = ...
    def __copy__(self):
        ...
    
    copy = ...
    def normkey(self, key):
        """Method to normalize dictionary key access"""
        ...
    
    def normvalue(self, value):
        """Method to normalize values prior to be setted"""
        ...
    
    def get(self, key, def_val: Optional[Any] = ...):
        ...
    
    def setdefault(self, key, def_val: Optional[Any] = ...):
        ...
    
    def update(self, seq):
        ...
    
    @classmethod
    def fromkeys(cls, keys, value: Optional[Any] = ...):
        ...
    
    def pop(self, key, *args):
        ...
    


class MergeDict(object):
    """
    A simple class for creating new "virtual" dictionaries that actually look
    up values in more than one dictionary, passed in the constructor.

    If a key appears in more than one of the given dictionaries, only the
    first occurrence will be used.
    """
    def __init__(self, *dicts):
        self.dicts = ...
    
    def __getitem__(self, key):
        ...
    
    def __copy__(self):
        ...
    
    def get(self, key, default: Optional[Any] = ...):
        ...
    
    def getlist(self, key):
        ...
    
    def items(self):
        ...
    
    def has_key(self, key):
        ...
    
    __contains__ = ...
    def copy(self):
        """Returns a copy of this object."""
        ...
    


class LocalCache(collections.OrderedDict):
    """Dictionary with a finite number of keys.

    Older items expires first.

    """
    def __init__(self, limit: Optional[Any] = ...):
        self.limit = ...
    
    def __setitem__(self, key, value):
        ...
    


class SequenceExclude(object):
    """Object to test if an item is NOT within some sequence."""
    def __init__(self, seq):
        self.seq = ...
    
    def __contains__(self, item):
        ...
    


