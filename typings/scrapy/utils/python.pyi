"""
This type stub file was generated by pyright.
"""

import six
import sys
from scrapy.utils.decorators import deprecated
from typing import Any, Optional

"""
This module contains essential stuff that should've come with Python itself ;)
"""
def flatten(x):
    """flatten(sequence) -> list

    Returns a single, flat list which contains all elements retrieved
    from the sequence and all recursively contained sub-sequences
    (iterables).

    Examples:
    >>> [1, 2, [3,4], (5,6)]
    [1, 2, [3, 4], (5, 6)]
    >>> flatten([[[1,2,3], (42,None)], [4,5], [6], 7, (8,9,10)])
    [1, 2, 3, 42, None, 4, 5, 6, 7, 8, 9, 10]
    >>> flatten(["foo", "bar"])
    ['foo', 'bar']
    >>> flatten(["foo", ["baz", 42], "bar"])
    ['foo', 'baz', 42, 'bar']
    """
    ...

def iflatten(x):
    """iflatten(sequence) -> iterator

    Similar to ``.flatten()``, but returns iterator instead"""
    ...

def is_listlike(x):
    """
    >>> is_listlike("foo")
    False
    >>> is_listlike(5)
    False
    >>> is_listlike(b"foo")
    False
    >>> is_listlike([b"foo"])
    True
    >>> is_listlike((b"foo",))
    True
    >>> is_listlike({})
    True
    >>> is_listlike(set())
    True
    >>> is_listlike((x for x in range(3)))
    True
    >>> is_listlike(six.moves.xrange(5))
    True
    """
    ...

def unique(list_, key=...):
    """efficient function to uniquify a list preserving item order"""
    ...

def to_unicode(text, encoding: Optional[Any] = ..., errors=...):
    """Return the unicode representation of a bytes object ``text``. If
    ``text`` is already an unicode object, return it as-is."""
    ...

def to_bytes(text, encoding: Optional[Any] = ..., errors=...):
    """Return the binary representation of ``text``. If ``text``
    is already a bytes object, return it as-is."""
    ...

def to_native_str(text, encoding: Optional[Any] = ..., errors=...):
    """ Return str representation of ``text``
    (bytes in Python 2.x and unicode in Python 3.x). """
    ...

def re_rsearch(pattern, text, chunk_size=...):
    """
    This function does a reverse search in a text using a regular expression
    given in the attribute 'pattern'.
    Since the re module does not provide this functionality, we have to find for
    the expression into chunks of text extracted from the end (for the sake of efficiency).
    At first, a chunk of 'chunk_size' kilobytes is extracted from the end, and searched for
    the pattern. If the pattern is not found, another chunk is extracted, and another
    search is performed.
    This process continues until a match is found, or until the whole file is read.
    In case the pattern wasn't found, None is returned, otherwise it returns a tuple containing
    the start position of the match, and the ending (regarding the entire text).
    """
    ...

def memoizemethod_noargs(method):
    """Decorator to cache the result of a method (without arguments) using a
    weak reference to its object
    """
    ...

_BINARYCHARS = six.b(chr(i)) for i in range(32) - b"\0", b"\t", b"\n", b"\r"
@deprecated("scrapy.utils.python.binary_is_text")
def isbinarytext(text):
    """ This function is deprecated.
    Please use scrapy.utils.python.binary_is_text, which was created to be more
    clear about the functions behavior: it is behaving inverted to this one. """
    ...

def binary_is_text(data):
    """ Returns ``True`` if the given ``data`` argument (a ``bytes`` object)
    does not contain unprintable control characters.
    """
    ...

def _getargspec_py23(func):
    """_getargspec_py23(function) -> named tuple ArgSpec(args, varargs, keywords,
                                                        defaults)

    Identical to inspect.getargspec() in python2, but uses
    inspect.getfullargspec() for python3 behind the scenes to avoid
    DeprecationWarning.

    >>> def f(a, b=2, *ar, **kw):
    ...     pass

    >>> _getargspec_py23(f)
    ArgSpec(args=['a', 'b'], varargs='ar', keywords='kw', defaults=(2,))
    """
    ...

def get_func_args(func, stripself: bool = ...):
    """Return the argument name list of a callable"""
    ...

def get_spec(func):
    """Returns (args, kwargs) tuple for a function
    >>> import re
    >>> get_spec(re.match)
    (['pattern', 'string'], {'flags': 0})

    >>> class Test(object):
    ...     def __call__(self, val):
    ...         pass
    ...     def method(self, val, flags=0):
    ...         pass

    >>> get_spec(Test)
    (['self', 'val'], {})

    >>> get_spec(Test.method)
    (['self', 'val'], {'flags': 0})

    >>> get_spec(Test().method)
    (['self', 'val'], {'flags': 0})
    """
    ...

def equal_attributes(obj1, obj2, attributes):
    """Compare two objects attributes"""
    ...

class WeakKeyCache(object):
    def __init__(self, default_factory):
        self.default_factory = ...
    
    def __getitem__(self, key):
        ...
    


@deprecated
def stringify_dict(dct_or_tuples, encoding=..., keys_only: bool = ...):
    """Return a (new) dict with unicode keys (and values when "keys_only" is
    False) of the given dict converted to strings. ``dct_or_tuples`` can be a
    dict or a list of tuples, like any dict constructor supports.
    """
    ...

@deprecated
def is_writable(path):
    """Return True if the given path can be written (if it exists) or created
    (if it doesn't exist)
    """
    ...

@deprecated
def setattr_default(obj, name, value):
    """Set attribute value, but only if it's not already set. Similar to
    setdefault() for dicts.
    """
    ...

def retry_on_eintr(function, *args, **kw):
    """Run a function and retry it while getting EINTR errors"""
    ...

def without_none_values(iterable):
    """Return a copy of ``iterable`` with all ``None`` entries removed.

    If ``iterable`` is a mapping, return a dictionary where all pairs that have
    value ``None`` have been removed.
    """
    ...

def global_object_name(obj):
    """
    Return full name of a global object.

    >>> from scrapy import Request
    >>> global_object_name(Request)
    'scrapy.http.request.Request'
    """
    ...

if hasattr(sys, "pypy_version_info"):
    def garbage_collect():
        ...
    
else:
    def garbage_collect():
        ...
    
class MutableChain(object):
    """
    Thin wrapper around itertools.chain, allowing to add iterables "in-place"
    """
    def __init__(self, *args):
        self.data = ...
    
    def extend(self, *iterables):
        self.data = ...
    
    def __iter__(self):
        ...
    
    def __next__(self):
        ...
    
    next = ...


