"""
This type stub file was generated by pyright.
"""

import sys
from typing import AsyncIterable, Iterable, Union
from scrapy.utils.decorators import deprecated

"""
This module contains essential stuff that should've come with Python itself ;)
"""
def flatten(x): # -> list[Unknown]:
    """flatten(sequence) -> list

    Returns a single, flat list which contains all elements retrieved
    from the sequence and all recursively contained sub-sequences
    (iterables).

    Examples:
    >>> [1, 2, [3,4], (5,6)]
    [1, 2, [3, 4], (5, 6)]
    >>> flatten([[[1,2,3], (42,None)], [4,5], [6], 7, (8,9,10)])
    [1, 2, 3, 42, None, 4, 5, 6, 7, 8, 9, 10]
    >>> flatten(["foo", "bar"])
    ['foo', 'bar']
    >>> flatten(["foo", ["baz", 42], "bar"])
    ['foo', 'baz', 42, 'bar']
    """
    ...

def iflatten(x): # -> Generator[Unknown, Any, None]:
    """iflatten(sequence) -> iterator

    Similar to ``.flatten()``, but returns iterator instead"""
    ...

def is_listlike(x): # -> bool:
    """
    >>> is_listlike("foo")
    False
    >>> is_listlike(5)
    False
    >>> is_listlike(b"foo")
    False
    >>> is_listlike([b"foo"])
    True
    >>> is_listlike((b"foo",))
    True
    >>> is_listlike({})
    True
    >>> is_listlike(set())
    True
    >>> is_listlike((x for x in range(3)))
    True
    >>> is_listlike(range(5))
    True
    """
    ...

def unique(list_, key=...): # -> list[Unknown]:
    """efficient function to uniquify a list preserving item order"""
    ...

def to_unicode(text, encoding=..., errors=...): # -> str:
    """Return the unicode representation of a bytes object ``text``. If
    ``text`` is already an unicode object, return it as-is."""
    ...

def to_bytes(text, encoding=..., errors=...): # -> bytes:
    """Return the binary representation of ``text``. If ``text``
    is already a bytes object, return it as-is."""
    ...

@deprecated('to_unicode')
def to_native_str(text, encoding=..., errors=...): # -> str:
    """ Return str representation of ``text``. """
    ...

def re_rsearch(pattern, text, chunk_size=...): # -> tuple[int | Unknown, int | Unknown] | None:
    """
    This function does a reverse search in a text using a regular expression
    given in the attribute 'pattern'.
    Since the re module does not provide this functionality, we have to find for
    the expression into chunks of text extracted from the end (for the sake of efficiency).
    At first, a chunk of 'chunk_size' kilobytes is extracted from the end, and searched for
    the pattern. If the pattern is not found, another chunk is extracted, and another
    search is performed.
    This process continues until a match is found, or until the whole file is read.
    In case the pattern wasn't found, None is returned, otherwise it returns a tuple containing
    the start position of the match, and the ending (regarding the entire text).
    """
    ...

def memoizemethod_noargs(method): # -> _Wrapped[(...), Unknown, (self: Unknown, *args: Unknown, **kwargs: Unknown), Unknown]:
    """Decorator to cache the result of a method (without arguments) using a
    weak reference to its object
    """
    ...

_BINARYCHARS = ...
def binary_is_text(data): # -> bool:
    """ Returns ``True`` if the given ``data`` argument (a ``bytes`` object)
    does not contain unprintable control characters.
    """
    ...

def get_func_args(func, stripself=...): # -> list[Unknown] | list[str]:
    """Return the argument name list of a callable"""
    ...

def get_spec(func): # -> tuple[list[str], dict[str, Any]]:
    """Returns (args, kwargs) tuple for a function
    >>> import re
    >>> get_spec(re.match)
    (['pattern', 'string'], {'flags': 0})

    >>> class Test:
    ...     def __call__(self, val):
    ...         pass
    ...     def method(self, val, flags=0):
    ...         pass

    >>> get_spec(Test)
    (['self', 'val'], {})

    >>> get_spec(Test.method)
    (['self', 'val'], {'flags': 0})

    >>> get_spec(Test().method)
    (['self', 'val'], {'flags': 0})
    """
    ...

def equal_attributes(obj1, obj2, attributes): # -> bool:
    """Compare two objects attributes"""
    ...

class WeakKeyCache:
    def __init__(self, default_factory) -> None:
        ...
    
    def __getitem__(self, key):
        ...
    


@deprecated
def retry_on_eintr(function, *args, **kw):
    """Run a function and retry it while getting EINTR errors"""
    ...

def without_none_values(iterable): # -> dict[Unknown, Unknown] | Any:
    """Return a copy of ``iterable`` with all ``None`` entries removed.

    If ``iterable`` is a mapping, return a dictionary where all pairs that have
    value ``None`` have been removed.
    """
    ...

def global_object_name(obj): # -> str:
    """
    Return full name of a global object.

    >>> from scrapy import Request
    >>> global_object_name(Request)
    'scrapy.http.request.Request'
    """
    ...

if hasattr(sys, "pypy_version_info"):
    def garbage_collect(): # -> None:
        ...
    
else:
    def garbage_collect(): # -> None:
        ...
    
class MutableChain(Iterable):
    """
    Thin wrapper around itertools.chain, allowing to add iterables "in-place"
    """
    def __init__(self, *args: Iterable) -> None:
        ...
    
    def extend(self, *iterables: Iterable) -> None:
        ...
    
    def __iter__(self): # -> Self@MutableChain:
        ...
    
    def __next__(self):
        ...
    
    @deprecated("scrapy.utils.python.MutableChain.__next__")
    def next(self):
        ...
    


class MutableAsyncChain(AsyncIterable):
    """
    Similar to MutableChain but for async iterables
    """
    def __init__(self, *args: Union[Iterable, AsyncIterable]) -> None:
        ...
    
    def extend(self, *iterables: Union[Iterable, AsyncIterable]) -> None:
        ...
    
    def __aiter__(self): # -> Self@MutableAsyncChain:
        ...
    
    async def __anext__(self):
        ...
    


