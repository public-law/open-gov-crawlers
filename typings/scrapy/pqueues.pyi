"""
This type stub file was generated by pyright.
"""

import logging
from collections import namedtuple
from queuelib import PriorityQueue
from typing import Any, Optional

logger = logging.getLogger(__name__)
def _path_safe(text):
    """
    Return a filesystem-safe version of a string ``text``

    >>> _path_safe('simple.org').startswith('simple.org')
    True
    >>> _path_safe('dash-underscore_.org').startswith('dash-underscore_.org')
    True
    >>> _path_safe('some@symbol?').startswith('some_symbol_')
    True
    """
    ...

class _Priority(namedtuple("_Priority", ["priority", "slot"])):
    """ Slot-specific priority. It is a hack - ``(priority, slot)`` tuple
    which can be used instead of int priorities in queues:

    * they are ordered in the same way - order is still by priority value,
      min(prios) works;
    * str(p) representation is guaranteed to be different when slots
      are different - this is important because str(p) is used to create
      queue files on disk;
    * they have readable str(p) representation which is safe
      to use as a file name.
    """
    __slots__ = ...
    def __str__(self):
        ...
    


class _SlotPriorityQueues(object):
    """ Container for multiple priority queues. """
    def __init__(self, pqfactory, slot_startprios: Optional[Any] = ...):
        """
        ``pqfactory`` is a factory for creating new PriorityQueues.
        It must be a function which accepts a single optional ``startprios``
        argument, with a list of priorities to create queues for.

        ``slot_startprios`` is a ``{slot: startprios}`` dict.
        """
        self.pqfactory = ...
        self.pqueues = ...
    
    def pop_slot(self, slot):
        """ Pop an object from a priority queue for this slot """
        ...
    
    def push_slot(self, slot, obj, priority):
        """ Push an object to a priority queue for this slot """
        ...
    
    def close(self):
        ...
    
    def __len__(self):
        ...
    
    def __contains__(self, slot):
        ...
    


class ScrapyPriorityQueue(PriorityQueue):
    """
    PriorityQueue which works with scrapy.Request instances and
    can optionally convert them to/from dicts before/after putting to a queue.
    """
    def __init__(self, crawler, qfactory, startprios=..., serialize: bool = ...):
        self.serialize = ...
        self.spider = ...
    
    @classmethod
    def from_crawler(cls, crawler, qfactory, startprios=..., serialize: bool = ...):
        ...
    
    def push(self, request, priority=...):
        ...
    
    def pop(self):
        ...
    


class DownloaderInterface(object):
    def __init__(self, crawler):
        self.downloader = ...
    
    def stats(self, possible_slots):
        ...
    
    def get_slot_key(self, request):
        ...
    
    def _active_downloads(self, slot):
        """ Return a number of requests in a Downloader for a given slot """
        ...
    


class DownloaderAwarePriorityQueue(object):
    """ PriorityQueue which takes Downlaoder activity in account:
    domains (slots) with the least amount of active downloads are dequeued
    first.
    """
    @classmethod
    def from_crawler(cls, crawler, qfactory, slot_startprios: Optional[Any] = ..., serialize: bool = ...):
        ...
    
    def __init__(self, crawler, qfactory, slot_startprios: Optional[Any] = ..., serialize: bool = ...):
        self.serialize = ...
    
    def pop(self):
        ...
    
    def push(self, request, priority):
        ...
    
    def close(self):
        ...
    
    def __len__(self):
        ...
    


