"""
This type stub file was generated by pyright.
"""

import logging
from http.client import HTTPConnection, HTTPResponse, HTTPSConnection
from io import BytesIO
from vcr.request import Request
from vcr.errors import CannotOverwriteExistingCassetteException
from . import compat

"""Stubs for patching HTTP and HTTPS requests"""
log = ...
class VCRFakeSocket:
    """
    A socket that doesn't do anything!
    Used when playing back cassettes, when there
    is no actual open socket.
    """
    def close(self): # -> None:
        ...
    
    def settimeout(self, *args, **kwargs): # -> None:
        ...
    
    def fileno(self): # -> Literal[0]:
        """
        This is kinda crappy.  requests will watch
        this descriptor and make sure it's not closed.
        Return file descriptor 0 since that's stdin.
        """
        ...
    


def parse_headers(header_list): # -> HTTPMessage:
    """
    Convert headers from our serialized dict with lists for keys to a
    HTTPMessage
    """
    ...

def serialize_headers(response): # -> dict[Unknown, Unknown]:
    ...

class VCRHTTPResponse(HTTPResponse):
    """
    Stub response class that gets returned instead of a HTTPResponse
    """
    def __init__(self, recorded_response) -> None:
        ...
    
    @property
    def closed(self): # -> bool:
        ...
    
    def read(self, *args, **kwargs): # -> bytes:
        ...
    
    def readall(self):
        ...
    
    def readinto(self, *args, **kwargs): # -> int:
        ...
    
    def readline(self, *args, **kwargs): # -> bytes:
        ...
    
    def readlines(self, *args, **kwargs): # -> list[bytes]:
        ...
    
    def seekable(self): # -> bool:
        ...
    
    def tell(self): # -> int:
        ...
    
    def isatty(self): # -> bool:
        ...
    
    def seek(self, *args, **kwargs): # -> int:
        ...
    
    def close(self): # -> Literal[True]:
        ...
    
    def getcode(self): # -> int:
        ...
    
    def isclosed(self): # -> bool:
        ...
    
    def info(self): # -> HTTPMessage:
        ...
    
    def getheaders(self): # -> list[tuple[Unknown, Unknown]]:
        ...
    
    def getheader(self, header, default=...): # -> str | None:
        ...
    
    def readable(self): # -> bool:
        ...
    


class VCRConnection:
    cassette = ...
    def request(self, method, url, body=..., headers=..., *args, **kwargs): # -> None:
        """Persist the request metadata in self._vcr_request"""
        ...
    
    def putrequest(self, method, url, *args, **kwargs): # -> None:
        """
        httplib gives you more than one way to do it.  This is a way
        to start building up a request.  Usually followed by a bunch
        of putheader() calls.
        """
        ...
    
    def putheader(self, header, *values): # -> None:
        ...
    
    def send(self, data): # -> None:
        """
        This method is called after request(), to add additional data to the
        body of the request.  So if that happens, let's just append the data
        onto the most recent request in the cassette.
        """
        ...
    
    def close(self): # -> None:
        ...
    
    def endheaders(self, message_body=...): # -> None:
        """
        Normally, this would actually send the request to the server.
        We are not sending the request until getting the response,
        so bypass this part and just append the message body, if any.
        """
        ...
    
    def getresponse(self, _=..., **kwargs): # -> VCRHTTPResponse:
        """Retrieve the response"""
        ...
    
    def set_debuglevel(self, *args, **kwargs): # -> None:
        ...
    
    def connect(self, *args, **kwargs): # -> Any | None:
        """
        httplib2 uses this.  Connects to the server I'm assuming.

        Only pass to the baseclass if we don't have a recorded response
        and are not write-protected.
        """
        ...
    
    @property
    def sock(self): # -> Any | VCRFakeSocket | None:
        ...
    
    @sock.setter
    def sock(self, value): # -> None:
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __setattr__(self, name, value): # -> None:
        """
        We need to define this because any attributes that are set on the
        VCRConnection need to be propagated to the real connection.

        For example, urllib3 will set certain attributes on the connection,
        such as 'ssl_version'. These attributes need to get set on the real
        connection to have the correct and expected behavior.

        TODO: Separately setting the attribute on the two instances is not
        ideal. We should switch to a proxying implementation.
        """
        ...
    
    def __getattr__(self, name): # -> Any:
        """
        Send requests for weird attributes up to the real connection
        (counterpart to __setattr above)
        """
        ...
    


class VCRHTTPConnection(VCRConnection):
    """A Mocked class for HTTP requests"""
    _baseclass = HTTPConnection
    _protocol = ...


class VCRHTTPSConnection(VCRConnection):
    """A Mocked class for HTTPS requests"""
    _baseclass = HTTPSConnection
    _protocol = ...
    is_verified = ...


