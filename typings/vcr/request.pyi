"""
This type stub file was generated by pyright.
"""

from .util import CaseInsensitiveDict

log = ...
class Request:
    """
    VCR's representation of a request.
    """
    def __init__(self, method, uri, body, headers) -> None:
        ...
    
    @property
    def headers(self): # -> HeadersDict:
        ...
    
    @headers.setter
    def headers(self, value): # -> None:
        ...
    
    @property
    def body(self): # -> BytesIO | bytes:
        ...
    
    @body.setter
    def body(self, value): # -> None:
        ...
    
    def add_header(self, key, value): # -> None:
        ...
    
    @property
    def scheme(self): # -> str:
        ...
    
    @property
    def host(self): # -> str | None:
        ...
    
    @property
    def port(self): # -> int | None:
        ...
    
    @property
    def path(self): # -> str:
        ...
    
    @property
    def query(self): # -> list[tuple[str, str]]:
        ...
    
    @property
    def url(self): # -> Unknown:
        ...
    
    @property
    def protocol(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class HeadersDict(CaseInsensitiveDict):
    """
    There is a weird quirk in HTTP.  You can send the same header twice.  For
    this reason, headers are represented by a dict, with lists as the values.
    However, it appears that HTTPlib is completely incapable of sending the
    same header twice.  This puts me in a weird position: I want to be able to
    accurately represent HTTP headers in cassettes, but I don't want the extra
    step of always having to do [0] in the general case, i.e.
    request.headers['key'][0]

    In addition, some servers sometimes send the same header more than once,
    and httplib *can* deal with this situation.

    Furthermore, I wanted to keep the request and response cassette format as
    similar as possible.

    For this reason, in cassettes I keep a dict with lists as keys, but once
    deserialized into VCR, I keep them as plain, naked dicts.
    """
    def __setitem__(self, key, value): # -> None:
        ...
    


